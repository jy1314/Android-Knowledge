# 指令重排序

指令**不按书写顺序执行**的情况称为指令重排序。

当然，指令重排序不是随便排，一个一万行的程序直接把最后一行当成第一行就给执行那不就逆天了了么，指令重排序是需要**遵循代码依赖情况**的。

举个例子，有如下代码：

```
int i = 0, b = 0;
i = i + 5;  //指令1
i = i*2;  //指令2
b = b + 3;  //指令3
```
对于上边标注的3个指令来说，指令2是对指令1有依赖的，所以指令2不能被排到指令1之前执行。但是指令3跟指令1和指令2都没有关系，所以指令3可以被排在指令1之前，或者指令1和指令2中间或者指令2后边执行都可以。

那么最终结果和没有重排序的执行结果是一样的。但是这种指令重排序在单线程中没有任何问题的，但是在多线程中就会出现问题了。

##抑制重排序
### 同步代码抑制指令重排序
将需要抑制指令重排序的代码放入同步代码块中，**在获取锁的时候，它前边的操作必须已经执行完成，不能和同步代码块重排序；在释放锁的时候，同步代码块中的代码必须全部执行完成，不能和同步代码块后边的代码重排序。**

虽然抑制重排序可以保证多线程程序按照我们期望的执行顺序进行执行，但是它抑制了处理器对指令执行的优化，原来能并行执行的指令现在只能串行执行，会导致一定程度的性能下降。

并且，同步代码块之前的代码可以重排序，同步代码块中的代码可以重排序，同步代码块之后的代码也可以进行重排序。

### volatile变量抑制指令重排序

还是那句老话，加锁会导致竞争同一个锁的线程阻塞，造成线程切换，代价比较大，volatile变量也提供了一些抑制指令重排序的语义。

1. volatile写之前的操作不会被重排序到volatile写之后。
2. volatile读之后的操作不会被重排序到volatile读之前。
3. 前边是volatile写，后边是volatile读，这两个操作不能重排序。

### final变量抑制指令重排序

在java语言中，用final修饰的字段被赋予了一些特殊的语义，它可以阻止某些重排序，具体的规则就这两条：

1. 在构造方法内对一个final字段的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。
2. 初次读一个包含final字段对象的引用，与随后初次读这个final字段，这两个操作不能重排序。


## 总结

1. synchronized可以把三个问题都解决掉，但是伴随着这种万能特性，是多线程在竞争同一个锁的时候会造成线程切换，导致线程阻塞，这个对性能的影响是非常大的。
2. volatile不能保证一系列操作的原子性，但是可以保证对于一个变量的读取和写入是原子性的，一个线程对某个volatile变量的写入是可以立即对其他线程可见的，另外，它还可以禁止处理器对一些指令执行的重排序。
3. final变量依靠它的禁止重排序规则，保证在使用过程中的安全性。一旦被赋值成功，它的值在之后程序执行过程中都不会改变，也不存在所谓的内存可见性问题。