# Java并发编程之原子性操作
## 共享变量
在一个线程调用一个方法的时候，会在**栈内存**上为**局部变量以及方法参数**申请一些内存。在方法调用结束的时候，这些内存便被释放。不同线程调用同一个方法都会为局部变量和方法参数拷贝一个副本，所以这个栈内存是**线程私有的**，也就是说**局部变量和方法参数是不可以共享的**。但是**对象或者数组**是在**堆内存**上创建的，**堆内存是所有线程都可以访问的，所以包括成员变量、静态变量和数组元素是可共享的**。

## 线程的安全性
**原子性操作**、**内存可见性**和**指令重排序**是构成线程安全性的三个主题。

## 原子性操作
一个或某几个操作只能在一个线程执行完之后，另一个线程才能开始执行该操作，也就是说这些操作是不可分割的，线程不能在这些操作上交替执行。

java中自带了一些原子性操作，比如给一个非long、double基本数据类型变量或者引用的赋值或者读取操作。而++操作就不是一个原子操作。

那么怎么保证操作的原子性呢？

### 从共享性解决
**1、尽量使用局部变量解决问题**

之前说过，局部变量(包括方法参数和方法体中创建的变量)是线程私有的，所以无论多少线程调用某个不涉及共享变量的方法都是安全的。

**2、使用ThreadLocal类**

为了维护一些线程内可以共享的数据，java提出了一个ThreadLocal类，它提供了下边这些方法。

```
public class ThreadLocal<T> {

    protected T initialValue() {
        return null;
    }

    public void set(T value) {
        ... 
    }

    public T get() {
        ... 
    }

    public void remove() {
         ...
     }
}
```

其中，类型参数T就代表了在同一个线程中共享数据的类型，它的各个方法的含义是：

T initialValue()：当某个线程初次调用get方法时，就会调用initialValue方法来获取初始值。

void set(T value)：调用当前线程将指定的value参数与该线程建立一对一关系(会覆盖initialValue的值)，以便后续get方法获取该值。

T get()：获取与当前线程建立一对一关系的值。

void remove()：将与当前线程建立一对一关系的值移除。

我们可以在**同一个线程里的任何代码处存取该类型的值**。
不同线程操作同一个 ThreadLocal 对象执行各种操作而不会影响其他线程里的值。

### 从可变性解决

如果一个变量可以被共享，但是它自打被创建之后就不能被修改，那么随意哪个线程去访问都可以，即把该变量声明为 final。

### 加锁解决
#### 锁
java语言里把锁给做了个抽象，任何一个对象都可以作为一个锁。某个线程在进入某个代码块的时候去获取一个锁，在退出该代码块的时候把锁给释放掉。从而实现原子操作。

```
		synchronized (锁对象) {
    		需要保持原子性的一系列代码
		}
```
#### 同步代码块

线程们按照获取锁的顺序执行的方式也叫做**同步执行**，被锁保护的代码块也叫做**同步代码块**。

要注意：在同步代码块中的代码要尽量的短，**不要把不需要同步的代码也加入到同步代码块，在同步代码块中千万不要执行特别耗时或者可能发生阻塞的一些操作**，比如I/O操作啥的。

#### 锁的重入
当一个线程请求获得已经被其他线程获得的锁的时候，它就会被阻塞，但是如果一个线程请求一个它已经获得的锁，那么这个请求就会成功。

也就是说**只要一个线程持有了某个锁，那么它就可以进入任何被这个锁保护的代码块**。

#### 同步方法
如果有整个方法都要同步，那么可以直接用synchronized关键字修饰方法，其实和方法体里加锁是一个效果，只不过使用的锁是this对象或者Class对象。

```
public synchronized 返回类型 方法名(参数列表) {
    需要被同步执行的代码
}

public synchronized static 返回类型 方法名(参数列表) {
    需要被同步执行的代码
}
```








